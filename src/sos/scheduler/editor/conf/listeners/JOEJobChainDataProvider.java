package sos.scheduler.editor.conf.listeners;

import static sos.scheduler.editor.app.SOSJOEMessageCodes.JOE_E_0002;

import java.util.List;

import org.apache.log4j.Logger;
import org.jdom.Element;
import org.jdom.xpath.XPath;

import sos.scheduler.editor.app.Editor;
import sos.scheduler.editor.app.ErrorLog;
import sos.scheduler.editor.app.JSObjectElement;
import sos.scheduler.editor.app.Utils;
import sos.scheduler.editor.classes.JobChainNodeWrapper;
import sos.util.SOSClassUtil;

import com.sos.VirtualFileSystem.Interfaces.ISOSVirtualFile;
import com.sos.scheduler.model.objects.JSObjJobChain;

/**
* \class JOEListener
*
* \brief JOEListener -
*
* \details
*
*
* \code
*   .... code goes here ...
* \endcode
*
* <p style="text-align:center">
* <br />---------------------------------------------------------------------------
* <br /> APL/Software GmbH - Berlin
* <br />##### generated by ClaviusXPress (http://www.sos-berlin.com) #########
* <br />---------------------------------------------------------------------------
* </p>
* \author KB
* \version $Id$
* \see reference
*
* Created on 16.11.2011 15:25:39
 */

/**
 * @author KB
 *
 */
public class JOEJobChainDataProvider extends JOEListener {

	@SuppressWarnings("unused")
	private final String			conClassName				= this.getClass().getSimpleName();
	@SuppressWarnings("unused")
	private static final String		conSVNVersion				= "$Id$";
	@SuppressWarnings("unused")
	private final Logger			logger						= Logger.getLogger(this.getClass());
	public static final String		conTagFILE_ORDER_SINK		= "file_order_sink";

	protected Element				objJobChain					= null;

	public static final String		conAttrSTATE				= "state";

	public static final String		conTagJOB_CHAIN_NODE		= "job_chain_node";
	public static final String		conAttrON_ERROR				= "on_error";
	public static final String		conAttrERROR_STATE			= "error_state";
	public static final String		conAttrJOBNAME				= "job_name";
	public static final String		conTagFILE_ORDER_SOURCE		= "file_order_source";
	public static final String		conAttrMAX					= "max";
	public static final String		conAttrDIRECTORY			= "directory";
	public static final String		conAttrREGEX				= "regex";
	public static final String		conAttrNEXT_STATE			= "next_state";
	public static final String		conAttrREPEAT				= "repeat";
	public static final String		conAttrDELAY_AFTER_ERROR	= "delay_after_error";

	protected Element				_config						= null;
	protected JobChainNodeWrapper	_node						= null;
	protected String[]				_states						= null;
	protected JSObjectElement		objJSObjectElement			= null;

	public JOEJobChainDataProvider() {
		strUpdateObjectType = "job_chain";
		strUpdateElementName = getChainName();
	}

	public JSObjectElement getJSObject() {
		if (objJSObjectElement == null) {
			objJSObjectElement = new JSObjectElement(Editor.JOB_CHAIN, objJobChain);
		}
		return objJSObjectElement;
	}

	public Element getChainElement() {
		return objJobChain;
	}

	private void setAttrYesNo(final String pstrAttr, final boolean pflgValue) {
		setAttr(pstrAttr, getBoolYesNo(pflgValue));
	}

	public boolean getRecoverable() {
		//			return objJSJobChain.isRecoverable();
		return Utils.isAttributeValue("orders_recoverable", objJobChain);
	}

	private void setAttr(final String pstrAttr, final String pstrVal) {
		Utils.setAttribute(pstrAttr, pstrVal, objJobChain);
		setDirty();
	}

	private String getAttr(final String pstrAttr) {
		String strValue = Utils.getAttributeValue(pstrAttr, objJobChain);
		return strValue;
	}

	public JOEJobChainDataProvider setTitle(final String pstrTitle) {
		setAttr("title", pstrTitle);
		return this;
	}

	public void setChainName(final String name) {
		setName(name);
	}

	public String getState() {
		String strR = _node.getState();
		if (strR == null) {
			strR = "";
		}
		return strR;
	}

	public JobChainNodeWrapper getNewJobChainNode() {
		Element node = new Element(conTagJOB_CHAIN_NODE);
		JobChainNodeWrapper objN = getJobChainNodeWrapper(node);
		objJobChain.addContent(node);
		return objN;
	}

	public JobChainNodeWrapper getNewFileOrderSinkNode() {
		Element node = new Element(conTagFILE_ORDER_SINK);
		JobChainNodeWrapper objN = getJobChainNodeWrapper(node);
		objJobChain.addContent(node);
		return objN;
	}

	public JobChainNodeWrapper getAJobChainNode() {
		Element node = new Element(conTagJOB_CHAIN_NODE);
		JobChainNodeWrapper objN = getJobChainNodeWrapper(node);
		return objN;
	}

	public JobChainNodeWrapper getAFileOrderSinkNode() {
		Element node = new Element(conTagFILE_ORDER_SINK);
		JobChainNodeWrapper objN = getJobChainNodeWrapper(node);
		return objN;
	}

	public List<Element> getFileOrderSinkList() {
		List<Element> lstFileSinks = objJobChain.getChildren(conTagFILE_ORDER_SINK);
		return lstFileSinks;
	}

	public String getDelay() {
		return _node.getDelay();
	}

	public void setState(final String state) {
		_node.setState(state);
	}

	public void setDelay(final String strDelay) {
		_node.setDelay(strDelay);
	}

	public String getJob() {
		return _node.getJobName();
	}

	public void setJob(final String strJobName) {
		_node.setJobName(strJobName);
	}

	public String getNextState() {
		return _node.getNextState();
	}

	public void setNextState(final String state) {
		_node.setNextState(state);
	}

	public String getErrorState() {
		String strR = "";
		if (_node != null) {
			strR = _node.getErrorState();
		}
		return strR;
	}

	public void setErrorState(final String state) {
		_node.setErrorState(state);
	}

	public String getOnError() {
		return _node.getOnError();
	}

	public void setOnError(final String strOnError) {
		_node.setOnError(strOnError);
	}

	public JobChainNodeWrapper getJobChainNodeWrapper(final Element pobjNode) {
		JobChainNodeWrapper objN = new JobChainNodeWrapper(pobjNode);
		objN.setDom(get_dom());
		objN.setChainName(getJobChainName());
		return objN;
	}

	public String getMoveTo() {
		return _node.getMoveTo();
	}

	public boolean getRemoveFile() {
		return _node.getRemoveFileB();
	}

	public void setMoveTo(final String moveTo) {
		_node.setMoveTo(moveTo);
	}

	public void setRemoveFile(final String removeFile) {
		_node.setRemoveFile(removeFile);
	}

	public void setRemoveFile(final boolean pflgRemoveFile) {
		setAttrYesNo("remove", pflgRemoveFile);
		setDirty();
	}

	public JOEJobChainDataProvider setName(final String pstrName) {
		setAttr("name", pstrName);
		return this;
	}

	public String getName() {
		return getAttr("name");
	}

	public String getTitle() {
		return getAttr("title");
	}

	public String getJobChainNameAndTitle() {
		String strT = getChainName() + " - " + getTitle();
		return strT;
	}

	public String getJobChainName() {
		String strT = getChainName();
		return strT;
	}

	public String getVisibleText() {
		return getAttr("title");
	}

	public String getMaxOrders() {
		return getAttr("MaxOrders");
	}

	public void setRecoverable(final boolean pflgIsOrdersRecoverable) {
		//		objJSJobChain.setOrdersRecoverable(pflgIsOrdersRecoverable);
		setOrdersRecoverable(getBoolYesNo(pflgIsOrdersRecoverable));
		setDirty();
	}

	public int intMaxOrders() {
		int i = 0;
		i = new Integer(getAttr("MaxOrders"));
		//		int i = objJSJobChain.getmaxOrders();
		return i;
	}

	public void setMaxorders(final int maxOrder) {
		//		objJSJobChain.setMaxorders(maxOrder);
		if (maxOrder == 0) {
			objJobChain.removeAttribute("max_orders");
		}
		else {
			setAttr("max_orders", maxOrder + "");
		}
		setDirty();
	}

	public JOEJobChainDataProvider setOrdersRecoverable(final boolean pflgorders_recoverable) {
		setAttrYesNo("orders_recoverable", pflgorders_recoverable);
		return this;
	}

	public JOEJobChainDataProvider setOrdersRecoverable(final String pstrorders_recoverable) {
		setAttr("orders_recoverable", pstrorders_recoverable);
		return this;
	}

	public JOEJobChainDataProvider setVisible(final boolean pflgVisible) {
		setAttrYesNo("visible", pflgVisible);
		//		objJSJobChain.setVisible(pflgIsVisible);
		return this;
	}

	public boolean getVisible() {
		//		return objJSJobChain.isVisible();
		return true;
	}

	public JOEJobChainDataProvider setVisible(final String pstrVisible) {
		setAttr("visible", pstrVisible);
		//		objJSJobChain.setVisible(pflgIsVisible);

		return this;
	}

	public boolean isDistributed() {
		boolean flgR = false;
		//		return objJSJobChain.isDistributed();
		flgR = getAttr("distributed").equalsIgnoreCase("yes");
		return flgR;
	}

	public void setDistributed(final boolean pflgIsDistributed) {
		//		objJSJobChain.setDistributed(pflgIsDistributed);
		setAttrYesNo("distributed", pflgIsDistributed);
		setDirty();
	}

	public JOEJobChainDataProvider setDistributed(final String pstrDistributed) {
		setAttr("distributed", pstrDistributed);
		//		objJSJobChain.setVisible(pflgIsVisible);

		return this;
	}

	public String getChainName() {
		String strT = "???";
		//		strT = objJSJobChain.getObjectName();
		strT = Utils.getAttributeValue("name", objJobChain);
		if (strT == null) {
			strT = "???";
		}
		return strT;
	}

	// ein Job Chain hat entweder job_chain_node ODER job_chain_node.job_chain
	// Kindknoten.
	public boolean hasNodesOrChains() {
		try {

			XPath x3 = XPath.newInstance("//job_chain[@name='" + getChainName() + "']/job_chain_node");
			List listOfElement_3 = x3.selectNodes(_dom.getDoc());
			XPath x4 = XPath.newInstance("//job_chain[@name='" + getChainName() + "']/file_order_sink");
			List listOfElement_4 = x4.selectNodes(_dom.getDoc());
			if (listOfElement_3.isEmpty() && listOfElement_4.isEmpty()) {
				return false;
			}
			else {
				return true;
			}
		}
		catch (Exception e) {
			new ErrorLog(JOE_E_0002.params(SOSClassUtil.getMethodName()), e);
			return true;
		}
	}

	public void getJOMJobChain() {
		getJobSchedulerObjectFactory();
		if (objJSJobChain == null) {
			String strFileName = _dom.getFilename();
			String strJobChainName = Utils.getAttributeValue("name", objJobChain);
			//getChainName();
			strFileName = strFileName + "/" + strJobChainName;
			strFileName = strFileName + JSObjJobChain.fileNameExtension; // ".job_chain.xml";
			ISOSVirtualFile objFile = objFileSystemHandler.getFileHandle(strFileName);

			if (objFile != null) {
				objJSJobChain = new JSObjJobChain(JobSchedulerObjectFactory, objFile);
			}
		}
	}

	public JobChainNodeWrapper getNode() {
		return _node;
	}

	public void clearNode() {
		logger.debug("_node set to null");
		_node = null;
	}

	public JobChainNodeWrapper setNode(final JobChainNodeWrapper pobjNode) {
		_node = pobjNode;
		return _node;
	}

	public JobChainNodeWrapper setNodeIfNull(final JobChainNodeWrapper pobjNode) {
		if (_node == null) {
			setNode(pobjNode);
		}
		//		logger.debug("_node set to null");
		return _node;
	}

	public JobChainNodeWrapper setNode(final Object pobjNode) {
		//		logger.debug("_node set to null");
		_node = (JobChainNodeWrapper) pobjNode;
		return _node;
	}

	@Override
	protected void setDirty() {
		super.setDirty();
		/**
		 * reload the content of the jobchain, this must be performed until the JOM is used only.
		 */
		objJSJobChain = null;
		getJOMJobChain();
	}

	public boolean isFullNode() {
		return getNode().isJobNode();
	}

	public boolean isFileSinkNode() {
		return getNode().isFileSinkNode();
	}

	public boolean isValidState(final String state) {
		if (_states != null) {
			for (int i = 0; i < _states.length; i++) {
				if (_states[i].equalsIgnoreCase(state) && !_states[i].equals(getState())) {
					return false;
				}
			}
		}
		return true;
	}

}
